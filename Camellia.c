
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char uchar;


void F_function(uchar X[8], uchar k[8], uchar Y[8]);
void S_function(uchar L[8]);
void FL_function(uchar X[8], uchar kl[64]);
void Inverse_FL_function(uchar X[8], uchar kl[8]);
void P_function(uchar Z[8]);
void Camellia(uchar k[32], uchar m[16], uchar c[16]);
void KeyExpansion(uchar key[32], uchar kw[4][8], uchar kl[6][8], uchar k[24][8]);
void Double_F(uchar cst1[8], uchar cst2[8], uchar k1[16], uchar k2[16], uchar Y[16]);
void Shift128_l(uchar S[16], int n);
void copy(uchar S[8], uchar D[8]);
void Six_F(uchar k[6][8], uchar M[16]);
void Shift32_l(uchar S[4], int n);

//四个S盒已经验证
 uchar S1[256] =
{
112,130, 44,236,179, 39,192,229,228,133, 87, 53,234, 12,174, 65,
 35,239,107,147, 69, 25,165, 33,237, 14, 79, 78, 29,101,146,189,
134,184,175,143,124,235, 31,206, 62, 48,220, 95, 94,197, 11, 26,
166,225, 57,202,213, 71, 93, 61,217,  1, 90,214, 81, 86,108, 77,
139, 13,154,102,251,204,176, 45,116, 18, 43, 32,240,177,132,153,
223, 76,203,194, 52,126,118,  5,109,183,169, 49,209, 23,  4,215,
 20, 88, 58, 97,222, 27, 17, 28, 50, 15,156, 22, 83, 24,242, 34,
254, 68,207,178,195,181,122,145, 36,  8,232,168, 96,252,105, 80,
170,208,160,125,161,137, 98,151, 84, 91, 30,149,224,255,100,210,
 16,196,  0, 72,163,247,117,219,138,  3,230,218,  9, 63,221,148,
135, 92,131,  2,205, 74,144, 51,115,103,246,243,157,127,191,226,
 82,155,216, 38,200, 55,198, 59,129,150,111, 75, 19,190, 99, 46,
233,121,167,140,159,110,188,142, 41,245,249,182, 47,253,180, 89,
120,152,  6,106,231, 70,113,186,212, 37,171, 66,136,162,141,250,
114,  7,185, 85,248,238,172, 10, 54, 73, 42,104, 60, 56,241,164,
 64, 40,211,123,187,201, 67,193, 21,227,173,244,119,199,128,158
};

 uchar S2[256] =
{
224,  5, 88,217,103, 78,129,203,201, 11,174,106,213, 24, 93,130,
 70,223,214, 39,138, 50, 75, 66,219, 28,158,156, 58,202, 37,123,
 13,113, 95, 31,248,215, 62,157,124, 96,185,190,188,139, 22, 52,
 77,195,114,149,171,142,186,122,179,  2,180,173,162,172,216,154,
 23, 26, 53,204,247,153, 97, 90,232, 36, 86, 64,225, 99,  9, 51,
191,152,151,133,104,252,236, 10,218,111, 83, 98,163, 46,  8,175,
 40,176,116,194,189, 54, 34, 56,100, 30, 57, 44,166, 48,229, 68,
253,136,159,101,135,107,244, 35, 72, 16,209, 81,192,249,210,160,
 85,161, 65,250, 67, 19,196, 47,168,182, 60, 43,193,255,200,165,
 32,137,  0,144, 71,239,234,183, 21,  6,205,181, 18,126,187, 41,
 15,184,  7,  4,155,148, 33,102,230,206,237,231, 59,254,127,197,
164, 55,177, 76,145,110,141,118,  3, 45,222,150, 38,125,198, 92,
211,242, 79, 25, 63,220,121, 29, 82,235,243,109, 94,251,105,178,
240, 49, 12,212,207,140,226,117,169, 74, 87,132, 17, 69, 27,245,
228, 14,115,170,241,221, 89, 20,108,146, 84,208,120,112,227, 73,
128, 80,167,246,119,147,134,131, 42,199, 91,233,238,143,  1, 61,
};

 uchar S3[256] = 
{ 
 56, 65, 22,118,217,147, 96,242,114,194,171,154,117,  6, 87,160,
145,247,181,201,162,140,210,144,246,  7,167, 39,142,178, 73,222,
 67, 92,215,199, 62,245,143,103, 31, 24,110,175, 47,226,133, 13,
 83,240,156,101,234,163,174,158,236,128, 45,107,168, 43, 54,166,
197,134, 77, 51,253,102, 88,150, 58,  9,149, 16,120,216, 66,204,
239, 38,229, 97, 26, 63, 59,130,182,219,212,152,232,139,  2,235,
 10, 44, 29,176,111,141,136, 14, 25,135, 78, 11,169, 12,121, 17,
127, 34,231, 89,225,218, 61,200, 18,  4,116, 84, 48,126,180, 40,
 85,104, 80,190,208,196, 49,203, 42,173, 15,202,112,255, 50,105,
  8, 98,  0, 36,209,251,186,237, 69,129,115,109,132,159,238, 74,
195, 46,193,  1,230, 37, 72,153,185,179,123,249,206,191,223,113,
 41,205,108, 19,100,155, 99,157,192, 75,183,165,137, 95,177, 23,
244,188,211, 70,207, 55, 94, 71,148,250,252, 91,151,254, 90,172,
 60, 76,  3, 53,243, 35,184, 93,106,146,213, 33, 68, 81,198,125,
 57,131,220,170,124,119, 86,  5, 27,164, 21, 52, 30, 28,248, 82,
 32, 20,233,189,221,228,161,224,138,241,214,122,187,227, 64, 79
};

 uchar S4[256] = 
{
112, 44,179,192,228, 87,234,174, 35,107, 69,165,237, 79, 29,146,
134,175,124, 31, 62,220, 94, 11,166, 57,213, 93,217, 90, 81,108,
139,154,251,176,116, 43,240,132,223,203, 52,118,109,169,209,  4,
 20, 58,222, 17, 50,156, 83,242,254,207,195,122, 36,232, 96,105,
170,160,161, 98, 84, 30,224,100, 16,  0,163,117,138,230,  9,221,
135,131,205,144,115,246,157,191, 82,216,200,198,129,111, 19, 99,
233,167,159,188, 41,249, 47,180,120,  6,231,113,212,171,136,141,
114,185,248,172, 54, 42, 60,241, 64,211,187, 67, 21,173,119,128,
130,236, 39,229,133, 53, 12, 65,239,147, 25, 33, 14, 78,101,189,
184,143,235,206, 48, 95,197, 26,225,202, 71, 61,  1,214, 86, 77,
 13,102,204, 45, 18, 32,177,153, 76,194,126,  5,183, 49, 23,215,
 88, 97, 27, 28, 15, 22, 24, 34, 68,178,181,145,  8,168,252, 80,
208,125,137,151, 91,149,255,210,196, 72,247,219,  3,218, 63,148,
 92,  2, 74, 51,103,243,127,226,155, 38, 55, 59,150, 75,190, 46,
121,140,110,142,245,182,253, 89,152,106, 70,186, 37, 66,162,250,
  7, 85,238, 10, 73,104, 56,164, 40,123,201,193,227,244,199,158,
};

 uchar BB[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

 uchar PP[8][8] =
{1,0,1,1,0,1,1,1,
1,1,0,1,1,0,1,1,
1,1,1,0,1,1,0,1,
0,1,1,1,1,1,1,0,
1,1,0,0,0,1,1,1,
0,1,1,0,1,0,1,1,
0,0,1,1,1,1,0,1,
1,0,0,1,1,1,1,0
};


/*********************************************************
//密钥扩展常量sigema
**********************************************************/
 uchar constant[6][8] =
{160,158,102,127, 59,204,144,139,
182,122,232, 88, 76,170,115,178,
198,239, 55, 47,233, 79,130,190,
84,255, 83,165,241,211,111, 28,
16,229, 39,250,222,104, 45, 29,
176, 86,136,194,179,230,193,253
};


 /*********************************************************
功能：输出函数
**********************************************************/
void shuchu(uchar S[16])
{
	int i;
	uchar s[32];
	for(i=0;i<16;i++)
	{
		s[0+2*i]=(S[i]&240)>>4;
		s[1+2*i]=S[i]&15;
	}

	for(i=0;i<32;i++)
		{
			printf("%x",s[i]);
			if((i+1)%2==0) printf(" ");

	    }
	printf("\n");
}

/*********************************************************
功能：拷贝函数
**********************************************************/
void copy(uchar S[8], uchar D[8])
{
	int i;
	for(i=0;i<8;i++)
		D[i] = S[i];
}

/**********************************************************
功能：对128位长度的序列进行左移
S:输入,输出，128位长度序列
n:输入，移动位数
在KeyExpansion中调用
************************************************************/
void Shift128_l(uchar S[16],int n)
{
	int n8,m8,k,k1,k2,j,h;
	uchar tmp1,tmp2;
	n8 = n/8;                        //进行字节移动的位数
	m8 = n%8;                        //进行位移动的位数
	//***************************字节移动*******************************//
	k=1;
	for(;n8>=1;n8/=2)
	{
		if(n8%2)
		{
			for(h=0;h<k;h++)
			{
				tmp1 = S[h];
				for(j=16-k;j>=0;j-=k)
				{
					tmp2 = S[j+h];
					S[j+h] = tmp1;
					tmp1=tmp2;
				}
			}
		}
		k=k*2;
	}
	//***********************位移动********************************//
	if(m8)
    {
		k1 = S[0]/BB[m8-1];       
		for(j=15;j>=0;j--)
		{
			k2 = S[j]/BB[m8-1];
			S[j] = S[j]*BB[7-m8]+k1;
			k1 = k2; 
		}
	}
}

/**********************************************************************
 *功能:对32位长度的序列进行左移
 *S:输入，输出，32位长度序列
 *n:输入，移动为数
 *在FL中调用
 * *******************************************************************/
void Shift32_l(uchar S[4], int n)
{
    int n8, m8, k, k1, k2, j, h;
    uchar tmp1, tmp2;
    n8 = n/8;
    m8 = n%8;
    k=1;
    for(;n8>=1;n8/=2)
    {
        if(n8%2)
        {
            for(h=0; h<k; h++)
            {
                tmp1 = S[h];
                for(j=4-k; j>-1;j-=k)
                {
                    tmp2 = S[j+h];
                    S[j+h] = tmp1;
                    tmp1 = tmp2;
                }
            }
        }
        k=k*2;
    }
    k1 = S[0]/BB[m8-1];
    for(j=3; j>=0; j--)
    {
        k2 = S[j]/BB[m8-1];
        S[j] = S[j]*BB[7-m8]+k1;
        k1 = k2;
    }
}

/**********************************************************************
功能：函数F
输入：X,k
输出：Y
**********************************************************************/
void F_function(uchar X[8],uchar k[8],uchar Y[8])
{
    int i;
	for(i=0;i<8;i++)
		Y[i] = X[i]^k[i];
	S_function(Y);
	P_function(Y);
} 
/***********************************************************
功能：调用四个S盒进行数字杂乱，抵抗差分分析与线性分析
***********************************************************/
void S_function(uchar L[8])
{
	L[0] = S1[L[0]];
	L[1] = S2[L[1]];
	L[2] = S3[L[2]];
	L[3] = S4[L[3]];
	L[4] = S2[L[4]];
	L[5] = S3[L[5]];
	L[6] = S4[L[6]];
	L[7] = S1[L[7]];
}  //S_function

/***********************************************************
功能：函数P
***********************************************************/
void P_function(uchar Z[8])
{
	 uchar t[8];
	int i,j;
	for(i=0;i<8;i++)
	{
		t[i] = Z[i];
		Z[i] = 0;
	}
	for(i=0;i<8;i++)
		for(j=0;j<8;j++)
			if(PP[i][j]==1)
				Z[i] ^= t[j];
}


/**********************************************************************
功能：两次feistel变换
输入：密钥key，密钥轮转常量
输出：两次轮转后的结果

***********************************************************************/

void Double_F(uchar cst1[8], uchar cst2[8],  //输入，变换需要的两个常数 
			uchar k1[16], uchar k2[16], //输入， key的左右两部分
			uchar Y[16]                 //输出			
			)
{
	 uchar t1[16], t2[16];  //临时变量，存储左右两部分
	int i;
//------------------------第一次feistel运算
	//第一步，首先左右异或
	for (i=0; i<16; i++)
	{
		t1[i] = k1[i]^k2[i];
	}
	//左半部分直接进入下轮的右半部分
	for (i=0; i<8; i++)
	{
		t2[i+8] = t1[i];
	}
	//festel变换
	F_function(t1, cst1, t2);
	for (i=0; i<8; i++)
	{
		t2[i] = t2[i]^t1[i+8];
	}
//------------------------第二次feistel运算 
	for (i=0; i<8; i++)
	{
		t1[i+8] = t2[i];
	}
	F_function(t2, cst2, t1);
	for (i=0; i<8; i++)
	{
		t1[i] = t1[i]^t2[i+8];
	}
//------------------------两轮运算结束
	for (i=0; i<16; i++)
	{
		Y[i] = t1[i];
	}
}

/********************************************************************
功能:密钥扩展
输入:密钥长度标识，初始密钥
输出:轮密钥
*********************************************************************/


void KeyExpansion(
	uchar key[32],  		//输入，初始密钥
	uchar kw[4][8], 		//输出，用于前期白化和后期白化
	uchar kl[6][8], 		//输出，用于FL
	uchar k[24][8])      //输出，在密钥
{
	 uchar klft[16], krgt[16], ka[16], kb[16],keyxorka[16];//klft,krgt分别对应密钥的左右两部分
	int i;

    int xx;
    for(i=0; i<24; i++)
    {
        for(xx=0;xx<8; xx++)
          k[i][xx]=0;
    }
	
    for (i=0; i<16; i++)
	{
		klft[i] = key[i];
	}
//-----------------密钥扩展-----------------------------
	for (i=0; i<16; i++)
	{
		krgt[i] = 0;
	}
//-----------------------Feistel变换------------------
	Double_F(constant[0], constant[1], klft, krgt, ka);
	Double_F(constant[2], constant[3], klft, ka, ka);
	Double_F(constant[4], constant[5], ka, krgt, kb);

/***********************************************************
 *KW，FL，FL-1（KL）轮密钥生成
 **********************************************************/
//for (i=0; i<16; i++)
//	{
//		keyxorka[i] = key[i]^ka[i];
//	}
//
//for (i=0; i<16; i++)
//	{
//		printf("%x,",keyxorka[i]);
//	}
//KW1:(KL<<<0)L KW2:(KL<<<0)R
	copy(klft, kw[0]);
	copy(&klft[8], kw[1]);
//轮1 轮2
//128bit  1:(KA<<<0)L 2:(kA<<<0)R
	copy(ka,k[0]);
	copy(&ka[8],k[1]);
//轮3 轮4
//128bit  3:(KL<<<15)L 4:(KL<<<15)R
	Shift128_l(klft,15);
	copy(klft,k[2]);
	copy(&klft[8],k[3]);
//轮5 轮6
//128bit  5:(KA<<<15)L 6:(KA<<<15)R
	Shift128_l(ka,15);
	copy(ka,k[4]);
	copy(&ka[8],k[5]);
//FL FL-1
//128bit  KL1:(KL<<<30)L KL2:(KL<<<30)R
	Shift128_l(ka,15);
	copy(ka,kl[0]);
	copy(&ka[8],kl[1]);
//轮7 轮8
//128bit  7:(KL<<<45)L 8:(KL<<<45)R
	Shift128_l(klft,30);
	copy(klft,k[6]);
	copy(&klft[8],k[7]);
//轮9 轮10
//128bit  9:(KA<<<45)L 10:(KA<<<45)R
	Shift128_l(ka,15);
	copy(ka,k[8]);
	Shift128_l(klft,15);
	copy(&klft[8],k[9]);
//轮11 轮12
//128bit  11:(KA<<<60)L 12:(KA<<<60)R
	Shift128_l(ka,15);
	copy(ka,k[10]);
	copy(&ka[8],k[11]);
//FL FL-1
//128bit KL3:(KL<<<77)L KL4:(KL<<<77)R
	Shift128_l(klft,17);
	copy(klft,kl[2]);
	copy(&klft[8],kl[3]);
/***************************************************************
  128bit  轮13 轮14 轮15 轮16 轮17 轮18
  13:(KL<<<94)L 14:(KL<<<94)R
  15:(KA<<<94)L 16:(KA<<<94)R
  17:(KL<<<111)L 18:(KL<<<111)R
  *************************************************************/
	Shift128_l(klft,17);
	copy(klft,k[12]);
	copy(&klft[8],k[13]);
	Shift128_l(ka,34);
	copy(ka,k[14]);
	copy(&ka[8],k[15]);
	Shift128_l(klft,17);
	copy(klft,k[16]);
	copy(&klft[8],k[17]);
//128bit  KW3:(KA<<<111)L KW4:(KA<<<111)R
	Shift128_l(ka,17);
	copy(ka,kw[2]);
	copy(&ka[8],kw[3]);


}


/***********************************************
 *功能:六轮函数F
***********************************************/
void Six_F(uchar k[6][8], uchar C[16])
{
    uchar t1[16],t2[8];
    int i, j;

    copy(C, t1);
    copy(&C[8], &t1[8]);
    for(i=0;i<6;i++)
    {
        F_function(t1, k[i], t2);

        for(j=0; j<8; j++)
        {
            t2[j] ^= t1[j+8];
        }
        copy(t1, &t1[8]);
        copy(t2, t1);
    }
    copy(t1, C);
    copy(&t1[8],&C[8]);
}


/****************************************************
 * 功能:FL函数
 * X改变
 * *************************************************/
void FL_function(uchar X[8], uchar kl[8])
{
    int i;
    uchar t[4];
    for(i=0; i<4; i++)
    {
        t[i]=X[i]&kl[i];  //序列X的左半部分与kl的左半部分
    }
    Shift32_l(t,1);   //序列左移一位
    for(i=4; i<8; i++)
    {
        X[i]^=t[i-4];  //得到变换后的序列的右半部分
    }
    for(i=0; i<4; i++)
    {
        X[i]^=X[i+4]|kl[i+4];   //得到序列的左半部分
    }
}

/*********************************************************
 *函数FL的逆
 *X受到改变
 * *******************************************************/
void Inverse_FL_function(uchar X[8], uchar kl[8])
{
    int i;
    uchar t[4];

    for(i=0; i<4; i++)
    {
        X[i] ^= X[i+4]|kl[i+4];
    }
    for(i=0;i<4;i++)
    {
        t[i]=X[i]&kl[i];
    }
    Shift32_l(t,1);
    for(i=4; i<8; i++)
    {
        X[i] ^= t[i-4];
    }
}


/**********************************************************************
 *功能:Camellia
 *klength=1:192比特密钥;kelength=2:256比特密钥;klength=0:128比特密钥
 *flag=0:decrypt;flag=1:encrypt;
 *k:加密密钥
 *M:input
 *C:output
 * *******************************************************************/

void Camellia(uchar k[32], uchar M[16], uchar C[16])
{
	 uchar kw[4][8],kl[6][8],tmp[8];
	 uchar key[24][8];
	
    int i;
    KeyExpansion(k, kw, kl, key);
	/*shuchu(key);
	shuchu(key+16);
	shuchu(key+32);*/

    copy(M, C);
    copy(&M[8],&C[8]);

//算法开始
//前期白化
    for(i=0; i<8; i++)
    {
        C[i]=C[i]^kw[0][i];
        C[i+8]=C[i+8]^kw[1][i];    
    }

    Six_F(key, C);

    FL_function(C, &kl[0][0]);
    Inverse_FL_function(&C[8],&kl[1][0]);

    Six_F(&key[6],C);
    FL_function(C, &kl[2][0]);
    Inverse_FL_function(&C[8],&kl[3][0]);

    Six_F(&key[12],C);
    
//后期白化
    for(i=0; i<8; i++)
    {
        tmp[i]=C[i]^kw[3][i];
        C[i]=C[i+8]^kw[2][i];
        C[i+8]=tmp[i];
    }
}


 uchar K[16]={0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};
 //uchar K[16]={0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
 uchar C[16];
 uchar M[16]={0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};


void main()
{
//int i,j,k;

//memset(C,0,sizeof(C));

  Camellia(K,M,C);

	printf("密钥：");
	shuchu(K);
	printf("明文：");
	shuchu(M);
	printf("密文：");
	shuchu(C);
	
}

